// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v3.20.3
// source: services/listenerrpc/service.proto

package listenerrpc

import (
	context "context"
	clientpb "github.com/chainreactors/malice-network/helper/proto/client/clientpb"
	implantpb "github.com/chainreactors/malice-network/helper/proto/implant/implantpb"
	lispb "github.com/chainreactors/malice-network/helper/proto/listener/lispb"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	ImplantRPC_Register_FullMethodName = "/listenerrpc.ImplantRPC/Register"
	ImplantRPC_SysInfo_FullMethodName  = "/listenerrpc.ImplantRPC/SysInfo"
	ImplantRPC_Ping_FullMethodName     = "/listenerrpc.ImplantRPC/Ping"
)

// ImplantRPCClient is the client API for ImplantRPC service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ImplantRPCClient interface {
	Register(ctx context.Context, in *lispb.RegisterSession, opts ...grpc.CallOption) (*implantpb.Empty, error)
	SysInfo(ctx context.Context, in *implantpb.SysInfo, opts ...grpc.CallOption) (*implantpb.Empty, error)
	Ping(ctx context.Context, in *implantpb.Ping, opts ...grpc.CallOption) (*implantpb.Empty, error)
}

type implantRPCClient struct {
	cc grpc.ClientConnInterface
}

func NewImplantRPCClient(cc grpc.ClientConnInterface) ImplantRPCClient {
	return &implantRPCClient{cc}
}

func (c *implantRPCClient) Register(ctx context.Context, in *lispb.RegisterSession, opts ...grpc.CallOption) (*implantpb.Empty, error) {
	out := new(implantpb.Empty)
	err := c.cc.Invoke(ctx, ImplantRPC_Register_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *implantRPCClient) SysInfo(ctx context.Context, in *implantpb.SysInfo, opts ...grpc.CallOption) (*implantpb.Empty, error) {
	out := new(implantpb.Empty)
	err := c.cc.Invoke(ctx, ImplantRPC_SysInfo_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *implantRPCClient) Ping(ctx context.Context, in *implantpb.Ping, opts ...grpc.CallOption) (*implantpb.Empty, error) {
	out := new(implantpb.Empty)
	err := c.cc.Invoke(ctx, ImplantRPC_Ping_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ImplantRPCServer is the server API for ImplantRPC service.
// All implementations must embed UnimplementedImplantRPCServer
// for forward compatibility
type ImplantRPCServer interface {
	Register(context.Context, *lispb.RegisterSession) (*implantpb.Empty, error)
	SysInfo(context.Context, *implantpb.SysInfo) (*implantpb.Empty, error)
	Ping(context.Context, *implantpb.Ping) (*implantpb.Empty, error)
	mustEmbedUnimplementedImplantRPCServer()
}

// UnimplementedImplantRPCServer must be embedded to have forward compatible implementations.
type UnimplementedImplantRPCServer struct {
}

func (UnimplementedImplantRPCServer) Register(context.Context, *lispb.RegisterSession) (*implantpb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Register not implemented")
}
func (UnimplementedImplantRPCServer) SysInfo(context.Context, *implantpb.SysInfo) (*implantpb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SysInfo not implemented")
}
func (UnimplementedImplantRPCServer) Ping(context.Context, *implantpb.Ping) (*implantpb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (UnimplementedImplantRPCServer) mustEmbedUnimplementedImplantRPCServer() {}

// UnsafeImplantRPCServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ImplantRPCServer will
// result in compilation errors.
type UnsafeImplantRPCServer interface {
	mustEmbedUnimplementedImplantRPCServer()
}

func RegisterImplantRPCServer(s grpc.ServiceRegistrar, srv ImplantRPCServer) {
	s.RegisterService(&ImplantRPC_ServiceDesc, srv)
}

func _ImplantRPC_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(lispb.RegisterSession)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImplantRPCServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ImplantRPC_Register_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImplantRPCServer).Register(ctx, req.(*lispb.RegisterSession))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImplantRPC_SysInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(implantpb.SysInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImplantRPCServer).SysInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ImplantRPC_SysInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImplantRPCServer).SysInfo(ctx, req.(*implantpb.SysInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImplantRPC_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(implantpb.Ping)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImplantRPCServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ImplantRPC_Ping_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImplantRPCServer).Ping(ctx, req.(*implantpb.Ping))
	}
	return interceptor(ctx, in, info, handler)
}

// ImplantRPC_ServiceDesc is the grpc.ServiceDesc for ImplantRPC service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ImplantRPC_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "listenerrpc.ImplantRPC",
	HandlerType: (*ImplantRPCServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Register",
			Handler:    _ImplantRPC_Register_Handler,
		},
		{
			MethodName: "SysInfo",
			Handler:    _ImplantRPC_SysInfo_Handler,
		},
		{
			MethodName: "Ping",
			Handler:    _ImplantRPC_Ping_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "services/listenerrpc/service.proto",
}

const (
	ListenerRPC_RegisterListener_FullMethodName = "/listenerrpc.ListenerRPC/RegisterListener"
	ListenerRPC_RegisterPipeline_FullMethodName = "/listenerrpc.ListenerRPC/RegisterPipeline"
	ListenerRPC_RegisterWebsite_FullMethodName  = "/listenerrpc.ListenerRPC/RegisterWebsite"
	ListenerRPC_StartTcpPipeline_FullMethodName = "/listenerrpc.ListenerRPC/StartTcpPipeline"
	ListenerRPC_StopTcpPipeline_FullMethodName  = "/listenerrpc.ListenerRPC/StopTcpPipeline"
	ListenerRPC_ListTcpPipelines_FullMethodName = "/listenerrpc.ListenerRPC/ListTcpPipelines"
	ListenerRPC_StartWebsite_FullMethodName     = "/listenerrpc.ListenerRPC/StartWebsite"
	ListenerRPC_StopWebsite_FullMethodName      = "/listenerrpc.ListenerRPC/StopWebsite"
	ListenerRPC_UploadWebsite_FullMethodName    = "/listenerrpc.ListenerRPC/UploadWebsite"
	ListenerRPC_ListWebsites_FullMethodName     = "/listenerrpc.ListenerRPC/ListWebsites"
	ListenerRPC_SpiteStream_FullMethodName      = "/listenerrpc.ListenerRPC/SpiteStream"
	ListenerRPC_JobStream_FullMethodName        = "/listenerrpc.ListenerRPC/JobStream"
)

// ListenerRPCClient is the client API for ListenerRPC service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ListenerRPCClient interface {
	RegisterListener(ctx context.Context, in *lispb.RegisterListener, opts ...grpc.CallOption) (*implantpb.Empty, error)
	RegisterPipeline(ctx context.Context, in *lispb.Pipeline, opts ...grpc.CallOption) (*implantpb.Empty, error)
	RegisterWebsite(ctx context.Context, in *lispb.Pipeline, opts ...grpc.CallOption) (*lispb.WebsiteResponse, error)
	StartTcpPipeline(ctx context.Context, in *lispb.CtrlPipeline, opts ...grpc.CallOption) (*clientpb.Empty, error)
	StopTcpPipeline(ctx context.Context, in *lispb.CtrlPipeline, opts ...grpc.CallOption) (*clientpb.Empty, error)
	ListTcpPipelines(ctx context.Context, in *lispb.ListenerName, opts ...grpc.CallOption) (*lispb.Pipelines, error)
	StartWebsite(ctx context.Context, in *lispb.CtrlPipeline, opts ...grpc.CallOption) (*clientpb.Empty, error)
	StopWebsite(ctx context.Context, in *lispb.CtrlPipeline, opts ...grpc.CallOption) (*clientpb.Empty, error)
	UploadWebsite(ctx context.Context, in *lispb.WebsiteAssets, opts ...grpc.CallOption) (*clientpb.Empty, error)
	ListWebsites(ctx context.Context, in *lispb.ListenerName, opts ...grpc.CallOption) (*lispb.Websites, error)
	// rpc ListenerCtrl(lispb.CtrlStatus) returns (stream lispb.CtrlPipeline);
	SpiteStream(ctx context.Context, opts ...grpc.CallOption) (ListenerRPC_SpiteStreamClient, error)
	JobStream(ctx context.Context, opts ...grpc.CallOption) (ListenerRPC_JobStreamClient, error)
}

type listenerRPCClient struct {
	cc grpc.ClientConnInterface
}

func NewListenerRPCClient(cc grpc.ClientConnInterface) ListenerRPCClient {
	return &listenerRPCClient{cc}
}

func (c *listenerRPCClient) RegisterListener(ctx context.Context, in *lispb.RegisterListener, opts ...grpc.CallOption) (*implantpb.Empty, error) {
	out := new(implantpb.Empty)
	err := c.cc.Invoke(ctx, ListenerRPC_RegisterListener_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *listenerRPCClient) RegisterPipeline(ctx context.Context, in *lispb.Pipeline, opts ...grpc.CallOption) (*implantpb.Empty, error) {
	out := new(implantpb.Empty)
	err := c.cc.Invoke(ctx, ListenerRPC_RegisterPipeline_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *listenerRPCClient) RegisterWebsite(ctx context.Context, in *lispb.Pipeline, opts ...grpc.CallOption) (*lispb.WebsiteResponse, error) {
	out := new(lispb.WebsiteResponse)
	err := c.cc.Invoke(ctx, ListenerRPC_RegisterWebsite_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *listenerRPCClient) StartTcpPipeline(ctx context.Context, in *lispb.CtrlPipeline, opts ...grpc.CallOption) (*clientpb.Empty, error) {
	out := new(clientpb.Empty)
	err := c.cc.Invoke(ctx, ListenerRPC_StartTcpPipeline_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *listenerRPCClient) StopTcpPipeline(ctx context.Context, in *lispb.CtrlPipeline, opts ...grpc.CallOption) (*clientpb.Empty, error) {
	out := new(clientpb.Empty)
	err := c.cc.Invoke(ctx, ListenerRPC_StopTcpPipeline_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *listenerRPCClient) ListTcpPipelines(ctx context.Context, in *lispb.ListenerName, opts ...grpc.CallOption) (*lispb.Pipelines, error) {
	out := new(lispb.Pipelines)
	err := c.cc.Invoke(ctx, ListenerRPC_ListTcpPipelines_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *listenerRPCClient) StartWebsite(ctx context.Context, in *lispb.CtrlPipeline, opts ...grpc.CallOption) (*clientpb.Empty, error) {
	out := new(clientpb.Empty)
	err := c.cc.Invoke(ctx, ListenerRPC_StartWebsite_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *listenerRPCClient) StopWebsite(ctx context.Context, in *lispb.CtrlPipeline, opts ...grpc.CallOption) (*clientpb.Empty, error) {
	out := new(clientpb.Empty)
	err := c.cc.Invoke(ctx, ListenerRPC_StopWebsite_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *listenerRPCClient) UploadWebsite(ctx context.Context, in *lispb.WebsiteAssets, opts ...grpc.CallOption) (*clientpb.Empty, error) {
	out := new(clientpb.Empty)
	err := c.cc.Invoke(ctx, ListenerRPC_UploadWebsite_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *listenerRPCClient) ListWebsites(ctx context.Context, in *lispb.ListenerName, opts ...grpc.CallOption) (*lispb.Websites, error) {
	out := new(lispb.Websites)
	err := c.cc.Invoke(ctx, ListenerRPC_ListWebsites_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *listenerRPCClient) SpiteStream(ctx context.Context, opts ...grpc.CallOption) (ListenerRPC_SpiteStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &ListenerRPC_ServiceDesc.Streams[0], ListenerRPC_SpiteStream_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &listenerRPCSpiteStreamClient{stream}
	return x, nil
}

type ListenerRPC_SpiteStreamClient interface {
	Send(*lispb.SpiteSession) error
	Recv() (*lispb.SpiteSession, error)
	grpc.ClientStream
}

type listenerRPCSpiteStreamClient struct {
	grpc.ClientStream
}

func (x *listenerRPCSpiteStreamClient) Send(m *lispb.SpiteSession) error {
	return x.ClientStream.SendMsg(m)
}

func (x *listenerRPCSpiteStreamClient) Recv() (*lispb.SpiteSession, error) {
	m := new(lispb.SpiteSession)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *listenerRPCClient) JobStream(ctx context.Context, opts ...grpc.CallOption) (ListenerRPC_JobStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &ListenerRPC_ServiceDesc.Streams[1], ListenerRPC_JobStream_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &listenerRPCJobStreamClient{stream}
	return x, nil
}

type ListenerRPC_JobStreamClient interface {
	Send(*clientpb.JobStatus) error
	Recv() (*clientpb.JobCtrl, error)
	grpc.ClientStream
}

type listenerRPCJobStreamClient struct {
	grpc.ClientStream
}

func (x *listenerRPCJobStreamClient) Send(m *clientpb.JobStatus) error {
	return x.ClientStream.SendMsg(m)
}

func (x *listenerRPCJobStreamClient) Recv() (*clientpb.JobCtrl, error) {
	m := new(clientpb.JobCtrl)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ListenerRPCServer is the server API for ListenerRPC service.
// All implementations must embed UnimplementedListenerRPCServer
// for forward compatibility
type ListenerRPCServer interface {
	RegisterListener(context.Context, *lispb.RegisterListener) (*implantpb.Empty, error)
	RegisterPipeline(context.Context, *lispb.Pipeline) (*implantpb.Empty, error)
	RegisterWebsite(context.Context, *lispb.Pipeline) (*lispb.WebsiteResponse, error)
	StartTcpPipeline(context.Context, *lispb.CtrlPipeline) (*clientpb.Empty, error)
	StopTcpPipeline(context.Context, *lispb.CtrlPipeline) (*clientpb.Empty, error)
	ListTcpPipelines(context.Context, *lispb.ListenerName) (*lispb.Pipelines, error)
	StartWebsite(context.Context, *lispb.CtrlPipeline) (*clientpb.Empty, error)
	StopWebsite(context.Context, *lispb.CtrlPipeline) (*clientpb.Empty, error)
	UploadWebsite(context.Context, *lispb.WebsiteAssets) (*clientpb.Empty, error)
	ListWebsites(context.Context, *lispb.ListenerName) (*lispb.Websites, error)
	// rpc ListenerCtrl(lispb.CtrlStatus) returns (stream lispb.CtrlPipeline);
	SpiteStream(ListenerRPC_SpiteStreamServer) error
	JobStream(ListenerRPC_JobStreamServer) error
	mustEmbedUnimplementedListenerRPCServer()
}

// UnimplementedListenerRPCServer must be embedded to have forward compatible implementations.
type UnimplementedListenerRPCServer struct {
}

func (UnimplementedListenerRPCServer) RegisterListener(context.Context, *lispb.RegisterListener) (*implantpb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterListener not implemented")
}
func (UnimplementedListenerRPCServer) RegisterPipeline(context.Context, *lispb.Pipeline) (*implantpb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterPipeline not implemented")
}
func (UnimplementedListenerRPCServer) RegisterWebsite(context.Context, *lispb.Pipeline) (*lispb.WebsiteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterWebsite not implemented")
}
func (UnimplementedListenerRPCServer) StartTcpPipeline(context.Context, *lispb.CtrlPipeline) (*clientpb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartTcpPipeline not implemented")
}
func (UnimplementedListenerRPCServer) StopTcpPipeline(context.Context, *lispb.CtrlPipeline) (*clientpb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopTcpPipeline not implemented")
}
func (UnimplementedListenerRPCServer) ListTcpPipelines(context.Context, *lispb.ListenerName) (*lispb.Pipelines, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTcpPipelines not implemented")
}
func (UnimplementedListenerRPCServer) StartWebsite(context.Context, *lispb.CtrlPipeline) (*clientpb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartWebsite not implemented")
}
func (UnimplementedListenerRPCServer) StopWebsite(context.Context, *lispb.CtrlPipeline) (*clientpb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopWebsite not implemented")
}
func (UnimplementedListenerRPCServer) UploadWebsite(context.Context, *lispb.WebsiteAssets) (*clientpb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UploadWebsite not implemented")
}
func (UnimplementedListenerRPCServer) ListWebsites(context.Context, *lispb.ListenerName) (*lispb.Websites, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListWebsites not implemented")
}
func (UnimplementedListenerRPCServer) SpiteStream(ListenerRPC_SpiteStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method SpiteStream not implemented")
}
func (UnimplementedListenerRPCServer) JobStream(ListenerRPC_JobStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method JobStream not implemented")
}
func (UnimplementedListenerRPCServer) mustEmbedUnimplementedListenerRPCServer() {}

// UnsafeListenerRPCServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ListenerRPCServer will
// result in compilation errors.
type UnsafeListenerRPCServer interface {
	mustEmbedUnimplementedListenerRPCServer()
}

func RegisterListenerRPCServer(s grpc.ServiceRegistrar, srv ListenerRPCServer) {
	s.RegisterService(&ListenerRPC_ServiceDesc, srv)
}

func _ListenerRPC_RegisterListener_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(lispb.RegisterListener)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ListenerRPCServer).RegisterListener(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ListenerRPC_RegisterListener_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ListenerRPCServer).RegisterListener(ctx, req.(*lispb.RegisterListener))
	}
	return interceptor(ctx, in, info, handler)
}

func _ListenerRPC_RegisterPipeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(lispb.Pipeline)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ListenerRPCServer).RegisterPipeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ListenerRPC_RegisterPipeline_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ListenerRPCServer).RegisterPipeline(ctx, req.(*lispb.Pipeline))
	}
	return interceptor(ctx, in, info, handler)
}

func _ListenerRPC_RegisterWebsite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(lispb.Pipeline)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ListenerRPCServer).RegisterWebsite(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ListenerRPC_RegisterWebsite_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ListenerRPCServer).RegisterWebsite(ctx, req.(*lispb.Pipeline))
	}
	return interceptor(ctx, in, info, handler)
}

func _ListenerRPC_StartTcpPipeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(lispb.CtrlPipeline)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ListenerRPCServer).StartTcpPipeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ListenerRPC_StartTcpPipeline_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ListenerRPCServer).StartTcpPipeline(ctx, req.(*lispb.CtrlPipeline))
	}
	return interceptor(ctx, in, info, handler)
}

func _ListenerRPC_StopTcpPipeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(lispb.CtrlPipeline)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ListenerRPCServer).StopTcpPipeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ListenerRPC_StopTcpPipeline_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ListenerRPCServer).StopTcpPipeline(ctx, req.(*lispb.CtrlPipeline))
	}
	return interceptor(ctx, in, info, handler)
}

func _ListenerRPC_ListTcpPipelines_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(lispb.ListenerName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ListenerRPCServer).ListTcpPipelines(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ListenerRPC_ListTcpPipelines_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ListenerRPCServer).ListTcpPipelines(ctx, req.(*lispb.ListenerName))
	}
	return interceptor(ctx, in, info, handler)
}

func _ListenerRPC_StartWebsite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(lispb.CtrlPipeline)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ListenerRPCServer).StartWebsite(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ListenerRPC_StartWebsite_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ListenerRPCServer).StartWebsite(ctx, req.(*lispb.CtrlPipeline))
	}
	return interceptor(ctx, in, info, handler)
}

func _ListenerRPC_StopWebsite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(lispb.CtrlPipeline)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ListenerRPCServer).StopWebsite(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ListenerRPC_StopWebsite_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ListenerRPCServer).StopWebsite(ctx, req.(*lispb.CtrlPipeline))
	}
	return interceptor(ctx, in, info, handler)
}

func _ListenerRPC_UploadWebsite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(lispb.WebsiteAssets)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ListenerRPCServer).UploadWebsite(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ListenerRPC_UploadWebsite_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ListenerRPCServer).UploadWebsite(ctx, req.(*lispb.WebsiteAssets))
	}
	return interceptor(ctx, in, info, handler)
}

func _ListenerRPC_ListWebsites_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(lispb.ListenerName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ListenerRPCServer).ListWebsites(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ListenerRPC_ListWebsites_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ListenerRPCServer).ListWebsites(ctx, req.(*lispb.ListenerName))
	}
	return interceptor(ctx, in, info, handler)
}

func _ListenerRPC_SpiteStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ListenerRPCServer).SpiteStream(&listenerRPCSpiteStreamServer{stream})
}

type ListenerRPC_SpiteStreamServer interface {
	Send(*lispb.SpiteSession) error
	Recv() (*lispb.SpiteSession, error)
	grpc.ServerStream
}

type listenerRPCSpiteStreamServer struct {
	grpc.ServerStream
}

func (x *listenerRPCSpiteStreamServer) Send(m *lispb.SpiteSession) error {
	return x.ServerStream.SendMsg(m)
}

func (x *listenerRPCSpiteStreamServer) Recv() (*lispb.SpiteSession, error) {
	m := new(lispb.SpiteSession)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ListenerRPC_JobStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ListenerRPCServer).JobStream(&listenerRPCJobStreamServer{stream})
}

type ListenerRPC_JobStreamServer interface {
	Send(*clientpb.JobCtrl) error
	Recv() (*clientpb.JobStatus, error)
	grpc.ServerStream
}

type listenerRPCJobStreamServer struct {
	grpc.ServerStream
}

func (x *listenerRPCJobStreamServer) Send(m *clientpb.JobCtrl) error {
	return x.ServerStream.SendMsg(m)
}

func (x *listenerRPCJobStreamServer) Recv() (*clientpb.JobStatus, error) {
	m := new(clientpb.JobStatus)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ListenerRPC_ServiceDesc is the grpc.ServiceDesc for ListenerRPC service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ListenerRPC_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "listenerrpc.ListenerRPC",
	HandlerType: (*ListenerRPCServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterListener",
			Handler:    _ListenerRPC_RegisterListener_Handler,
		},
		{
			MethodName: "RegisterPipeline",
			Handler:    _ListenerRPC_RegisterPipeline_Handler,
		},
		{
			MethodName: "RegisterWebsite",
			Handler:    _ListenerRPC_RegisterWebsite_Handler,
		},
		{
			MethodName: "StartTcpPipeline",
			Handler:    _ListenerRPC_StartTcpPipeline_Handler,
		},
		{
			MethodName: "StopTcpPipeline",
			Handler:    _ListenerRPC_StopTcpPipeline_Handler,
		},
		{
			MethodName: "ListTcpPipelines",
			Handler:    _ListenerRPC_ListTcpPipelines_Handler,
		},
		{
			MethodName: "StartWebsite",
			Handler:    _ListenerRPC_StartWebsite_Handler,
		},
		{
			MethodName: "StopWebsite",
			Handler:    _ListenerRPC_StopWebsite_Handler,
		},
		{
			MethodName: "UploadWebsite",
			Handler:    _ListenerRPC_UploadWebsite_Handler,
		},
		{
			MethodName: "ListWebsites",
			Handler:    _ListenerRPC_ListWebsites_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SpiteStream",
			Handler:       _ListenerRPC_SpiteStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "JobStream",
			Handler:       _ListenerRPC_JobStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "services/listenerrpc/service.proto",
}
